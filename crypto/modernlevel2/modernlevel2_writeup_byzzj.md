# modernlevel2

## 题目给了p和q的生成方法，也就是q是p+200的基础上的下一个质数，也就是p q的相差不会很大，所以我们将n开方，求出开方后的数设为p0，求出p0的下一个质数也就求出了p or q 经过验证，这种方法是可行的，多的不说直接上代码

```python
from gmpy2 import *



e = 65537

n = 11452010781700945194885825041576062986459518908306236134883328219517836024598026208955696553466356976655285845930140983979489852290887417163608580932722971467307682405491077376018369459515789913368303574417681788325455105338307621973257068929393305388898839690244153718746827687568943142691442635784625598829381099634577569705175939069109796551936046863666665803190700634925058131880700625313516365992771400685157818702377591189120059614640797633805032826339976362099630166292672342242548491136018848936907718521782199257834555743196912134846734216780693388395514132890246009933711615636241210592358939553573542211819

ct = 9382386979474197616144088395738511117415189424480345278098296234085580465803095421447618181033010892934720552109100687586227982392830094172696398522458973754177021361766105346902541300790244492117317758091403023252784848502593449769272896021364277011881515963010498133186088674278701557727586162691362516407553912163513619887584747151406626810049968827358946174418762292795577094677161610460397219058585176606399191455614959905686529126164845087444605951601034877672666624099507173139214278464954601405225319567756189509539041000276226967410931720110007078492044372679522665891455154054955207519643074493274717337763

p0 = iroot(n,2)[0]

while not is_prime(p0):
    p0 += 1

assert n%p0 == 0
assert is_prime(n/p0)==True
p = p0
q = n/p0

fn = (p-1)*(q-1)

d = invert(e,fn)

m = hex(pow(ct,d,n))[2:].decode('hex')
print m
```
## 于是我们得到了flag
## flag{we_always_have_special_cases}
